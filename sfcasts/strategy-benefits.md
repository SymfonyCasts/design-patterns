# Strategy Part 2: Benefits & In the Wild

We just used the Strategy Pattern to allow things *outside* of the `Character` class to control *how* attacks happen by creating a custom `AttackType` and then passing it in when you create the character. If you've read up on this pattern, you might be wondering why we didn't name the interface attack strategy after the Strategy Pattern, which you often see when studying this pattern. The answer is... because I don't *have* to. In all seriousness, the clarity and purpose of this class are much more valuable than hinting the name of a pattern. In this case, if we call this "attack strategy", it might sound like it's responsible for actually *planning* a strategy of attack. That's *not* what we intended, hence our use of `AttackType`.

Let's do one more quick strategy pattern example to further balance our characters. I want to be able to control the armor of each character beyond just the number that's being passed in right now. This is used down in `receiveAttack()` to figure out how much the attack can be *reduced* by. That's *fine* for what we have now. But we're going to start creating very different types of armor like shield armor or leather armor that have different properties beyond just a number, so we'll need to upgrade our code to handle this.

Once again, we *could* solve this by creating *sub-classes*, like `characterWithShield`. But now you can probably see why that's not a good plan. If we had used inheritance for customizing how the attacks happen, we may end up with classes like `twoHandedSwordWithShieldCharacter` or `spellCastingAndBowUsingWearingLeatherArmorCharacter`. We would need one sub-class *per* combination. Yikes!

So rather than navigate that nightmare of neverending sub-classes, let's use the *Strategy Pattern*. Go back to the three steps from earlier. Step one is to *identify* the code that needs to change. In our case, we need to figure out how much an attack should be reduced by and create an interface for that. So let's create a new `/ArmorType` directory. And inside that, I'll create a new PHP class, which will actually be an `Interface` and we'll call this `ArmorType`. In this case, to model that code, we'll say `public function getArmorReduction()` where we pass in the `$damage` that we're about to do, and we'll `return` how much damage reduction the armor should do.

Step two is to create at least one implementation of this. For example, let's create a new PHP class called `ShieldType`, and we'll make it implement `ArmorType`. Below, I'll generate the `getArmorReduction()` method. The shield is cool because it's going to have a 20% chance to block an incoming attack *entirely*. So I'll create a `$chanceToBlock` variable set to `Dice::roll(100)`. Then, if the `$chanceToBlock` is `> 80`, we are going to reduce *all* of the damage, so return `$damage`, *else* our shield is going to be meaningless and reduce the damage by zero. Once again, while we're here, I'm going to create two other types of armor. The first is a `LeatherArmorType`. I'll paste in the logic there for just 20% damage absorption. And *then*, we'll create a cool `IceBlockType` - a little something for our magic folk. I'll paste that logic in as well. And this will absorb two eight-sided dice rolls added together.

Step three will allow an object of the `ArmorType` interface to be passed into `Character`, which will then use its logic. In this case, we won't need this `$armor` number at all. We want this to be more intelligent than that. And now, add a new argument called `private ArmorType $armorType`. Then, down below in `receiveAttack()`, we'll say `$armorReduction = $this->armorType->getArmorReduction()` and we'll pass in `$damage`. And just to make sure things don't drift into the negative here, I'll add a `max()` after `$damageTaken` and set `$damage - $armorReduction, 0`. Done! Our character now leverages the Strategy Pattern for the `ArmorType`, which means we can take advantage of it over in `GameApplication.php`.

The first thing I'll do is remove the armor number that we have on all of these. Then I'll quickly pass in an `ArmorType` for each of these: `new ShieldType(),` `new LeatherArmorType()`, and  `new IceBlockType()`. For our `mage-archer`, which is our weird character, we'll *keep it* weird by giving them a shield - `new ShieldType()`. That's a lot to carry! Oh, and I also need to make sure I take off the armor number for it as well. Perfect!

Okay, let's go try this. Head over and run:

```terminal
./bin/console app:game:play
```

And... looks like it's working! Let's play as a `mage-archer` and... sweet! Well, I *lost*. That's *not* sweet, but you can see that the "damage dealt" and the "damage received" still seems to be working. Awesome!

So *that's* the Strategy Pattern! When do you *need* it? When you find that you want to swap out just *part* of the code inside of a clas. And what are the *benefits*? A bunch! Unlike inheritance, we can now create characters with endless combinations of attack and armor behaviors. We could also swap out an `AttackType` or `ArmorType` at run time. This means that we could, for example, read some configuration or environment variable and dynamically use it to change one of the attack types of our characters on the fly. That's simply not possible with inheritance.

If you watched our SOLID tutorial, the Strategy Pattern is a clear win for SRP and OCP (SRP - the "Single Responsibility Pattern" and OCP - the "Open Closed Principle"). The Strategy Pattern allows us to break big classes like `Character` into smaller, more focused ones, but still have them interact with each other. And OCP is happy because we now have a way to modify or extend the behavior of the `Character` class without actually *changing* the `Character` class, passing in new armor and attack types instead. We're effectively changing code inside of this without having to *physically* change the code.

Finally, where might we see this pattern in the real world? One example, if you hit "shift" + "shift" and type in "session.php", is Symfony's `Session` class. The `Session` is a simple key value store, but different apps will need to store that data in different locations. Instead of trying to accomplish that with a bunch of code inside of the `Session` class itself, the `Session` class accepts a `SessionStorageInterface`. We can pass whatever session storage strategy we want. Heck, we could even use environment variables to swap to a different storage at run time.

Where else is the Strategy Pattern used? Well, it's subtle, but it's actually used in a lot of places. Anytime you have a class that accepts an Interface as a constructor argument, especially if that interface comes from the same library, that's quite possibly the Strategy Pattern. It means the library author decided that, instead of putting a bunch of code in the middle of the class, it should be abstracted into another class. *And*, by typehinting the Interface, someone can swap out the implementation (in this case, these session storage) for *any* implementation.

Here's another example. Over on GitHub, I'm on the Symfony repository. I'm going to search for "login authenticator", which is the code behind the `json_login` way of logging in with Symfony. One common thing that you want to do with the `JsonLoginAuthenticator` is use it like you normally would and have it do all of the normal work, but then you control what happens on `success` - to control what JSON is returned from your application after you log in, for example. To allow for that, the `JsonLoginAuthenticator` allows you to pass in an `AuthenticationSuccessHandlerInterface`. So instead of *this* class trying to figure out what to do on `success`, it allows *us* to pass in a custom implementation of this that completely controls what to do on `success`.

Think you've got all that? Great! Let's talk about the Builder Pattern *next*.
