# Builder in Symfony & with a Factory

What if, in order to instantiate the `Character` objects, `CharacterBuilder` needed to, for example, make a *query* to the database? Well, when we need to make a query to the database, we normally give our class a constructor and then autowire the service we need. But `CharacterBuilder` *isn't* a service. You could *technically* use it like a service, but a service is a class that typically only needs a single instance. In `GameApplication.php` however, we're creating one `CharacterBuilder` *per* character. If we *did* try to autowire `CharacterBuilder` into `GameApplication.php`, that *would* work. Symfony would autowire the EntityManager into `CharacterBuilder` and then it would pass us the `CharacterBuilder` object with the `$ntityManager` inside. The *problem* is it would mean that we only had one `CharacterBuilder` when we actually need *four* to create our four `Character` objects. This is why builder objects are commonly partnered with a builder factory. Let me undo all of the changes I just made to `GameApplication.php` and `CharacterBuilder`.

Now, over in the `/Builder` directory, we're going to create a new class called `CharacterBuilderFactory`. By the way, there *is* a pattern called the factory pattern, which we won't *specifically* cover in this tutorial, but a "factory" is just a class whose job is to create *another* class. It, like the builder pattern, is a *creation pattern*. Inside of this, I'm going to create a new method called, how about... `createBuilder()`, which will return a `CharacterBuilder`. And inside of *that*, we'll just `return new CharacterBuilder()`.

This `CharacterBuilder` is a *service*. Even if we need *five* `CharacterBuilders` in our application, we only need *one* `CharacterBuilderFactory`. We'll just call this method on it *five* times. That means, over in `GameApplication.php`, we can create a `public function __construct()` and autowire `CharacterBuilderFactory $characterBuilderFactory`. I'll also add `private` in front of that so it's a property. Then, down inside of our `createCharacterBuilder()`, instead of creating this by hand, we'll rely on the factory, so `return $this->characterBuilderFactory->createBuilder()`. The nice thing about this factory (and this is really a benefit of the factory pattern in general) is that we have *centralized* the instantiation of this object.

How does that help us in this situation? If you remember, the problem I imagined was: What if our character builder needed a service like the EntityManager? With our new setup, we can make that happen. I don't actually have Doctrine installed in this project, so instead of the EntityManager, let's autowire `LoggerInterface $logger`... and I'll add `private` in front of that to turn that into a property as well. Then, down in `buildCharacter()`, just to test that this is working, let's use that: `$this->logger->info('Creating a character)`. I'll also pass a second argument, which will act as some context. We could say something like `'maxHealth' => $this->maxHealth` and `'baseDamage' => $this->baseDamage`. If you want to, you can add more stats below that, but that's enough for what we're trying to do.

So now that `CharacterBuilder` requires a `$logger`, we can very easily handle that in `CharacterBuilderFactory`. This is a *service*, so autowiring a `LoggerInterface` will work here. Then, we can just pass that *manually* into `$logger`. We're seeing some of the benefits of a factory pattern here. Since we've already centralized the creation of the `CharacterBuilder`, anywhere we use this factory, like `GameApplication.php`, doesn't need to change at all. So even though we just added a new constructor argument to `CharacterBuilder`, `GameApplication.php` doesn't need to change. It was offloading all of that work to the `CharacterBuilderFactory`.

To see if this is working, we can run

```terminal
./bin/console app:game:play -vv
```

The `-vv` will allow us to see log messages while we play. And... got it! Look! Our `[info] Creating a character` message popped up. We can't see the other stats here on this screen, but they could be seen in a log file. *Awesome*.

So *that's* the builder pattern. What problems can it solve? Simple! You have an object that's difficult to instantiate, so you add a builder class to make life easier. It also helps with the Single Responsibility Principle. It's one of the strategies that helps abstract creation logic of a class *away* from the class that will work with that object. Previously, in `GameApplication.php`, we had the complexity of both *creating* the objects *and* using them. We still have code here to use the builder, but most of the complexity is over in our builder class.

Frequently, when you study this pattern, it will tell you that the builder (`CharacterBuilder`, for example) should implement a new interface, like `CharacterBuilderInterface`, which would have methods on it like `setMaxHealth()`, `setBaseDamage()`, etc. This is *optional*. When would you *need* it? Well, like all interfaces, it's useful if you want to be able to swap *how* your characters are built at run time.

For example, imagine we created a *second* builder that implemented `CharacterBuilderInterface` called `DoubleHitPointsCharacterBuiltDoubleMaxHealthCharacterBuilder`, which creates the `Character` object, but in a slightly different way that maybe... *doubles* the `$maxHealth`. If both of those builders implemented this `CharacterBuilderInterface`, then inside of our `CharacterBuilderFactory`, which would now *return* `CharacterBuilderInterface`, we could actually read some config here and figure out which `CharacterBuilder` we want to use. So it really has less to do with the builder pattern itself, and more to do with making your code more flexible. Let me undo that fake code inside of `CharacterBuilderFactory`, and inside of `CharacterBuilder`, I'll remove that make-believe interface.

So where might we see the builder pattern in the wild? This one is pretty easy to spot, since method chaining is such a common feature of builders. The first one that comes to mind is Doctrine's QueryBuilder, which is (no surprise) based on its name. It allows us to configure a query with a bunch of nice methods before finally calling `getQuery()` to actually create the query object. It also leverages that factory pattern, because you call `createQueryBuilder()` where the base EntityRepository is responsible for instantiating the QueryBuilder. Another example is Symfony's FormBuilder. In that case, we don't call the `buildForm()` method, but Symfony *eventually* does once we're done configuring it.

Next, let's talk about the *observer pattern*.
