# Publish-Subscriber (PubSub)

The next pattern pattern I want to talk about maybe *isn't* its own pattern. In reality, it's more of a *variation* of the observer pattern. It's called "pub/sub" or "publish subscribe". The key difference be between observer and pub/sub is simply *who* handles notifying the observers. With the observer pattern, it's the *subject* - the thing (in our case, `GameApplication`) that does the work. With pub/sub, there's a third object called a "publisher". I'm going to call it an "event dispatcher" - a name that's probably more familiar to most of us. With pub/sub, the observers (also called "listeners") tell the dispatcher which events it wants to listen to. Then, the subject (whatever is doing the work) simply tells the dispatcher to dispatch the event. The dispatcher is then responsible for actually *calling* the methods on those objects. You *could* argue that pub/sub better follows the Single Responsibility pattern. Battling characters and then registering and calling the observers are two separate responsibilities that we've jammed inside of a `GameApplication`. So let's use the pub/sub pattern to add new functionality to our app.

I want a way to run code *before* a battle starts. Step one is to create an event class. This will be the object that is passed as an argument to all of your listeners. It's pretty much *identical* to the `FightResult` that we pass to our observers, but with the pub/sub pattern, it's customary to create an event class *just* for the event system. So inside of `/src`, I'm going to create a new `/Event` directory. Inside of that, create a new PHP class. You can call it whatever you want, but for this tutorial, let's call it `FightStartingEvent`. This class doesn't need to look like or extend anything, and we'll talk more about it in a minute.

Step *two* is dispatching this event *inside* of `GameApplication`. Instead of writing our own event dispatcher, we're going to use Symfony's EventDispatcher. Let me break the constructor onto multiple lines... and let's add a new `private EventDispatcherInterface $eventDispatcher` so that it autowires Symfony's EventDispatcher here. Then, down in `play()`, right at the very beginning, we'll say `$this->eventDispatcher->dispatch()`, and then create a `new FightStartingEvent()`. That's *it*! That's enough for the dispatcher to notify all of the code that is listening to the `FightStartingEvent()`. At the moment, *nothing* is listening.

So *finally*, we're going to register a listener for this event. To start, find `GameCommand` - the place where we're setting up and initializing our app. We'll see how to do all of this properly with Symfony's container in a minute, but I want to keep it simple starting out. We need to do the same thing here and get access to `$eventDispatcher`. So let's autowire it: `private readonly EventDispatcherInterface $eventDispatcher`. I *am* being a little inconsistent when I use `readonly` and `not`. Technically, I *could* use `readonly` on *all* of the construct arguments. It's not really important.

Down here, anywhere before our application actually starts, I'm going to say `$this->eventDispatcher->`. Notice that the only method on this is called `dispatch`. This is actually a *tiny* mistake I made. Let's back up for a second. In `GameApplication`, when I autowired `EventDispatcherInterface`, I actually got the one from `Psr\EventDispatcher\EventDispatcherInterface`, which is *great*. And inside of `GameCommand`, you can see that I did the *same* thing. But if you want the ability to actually attach listeners at *run time*, you'll want to get the one from `Symfony\Component\EventDispatcher` instead of `Psr`. In reality, even though we're using two different type hints in these classes, this is going to pass us the same `EventDispatcher` object. That object has a method on it called `addListener()`, so even if I had used the *old* interface, this method *would* have existed. It just would have looked funny inside of my editor.

The first argument of this is the *name* of the event, which is going to match the class name that we're dispatching. So we can say `FightStartingEvent::class`. And then, to keep it simple, I'm going to be lazy and just pass an inline `function()`. Sweet! I'll also `use ($io)` function so I can get that inside of here. Say `$io->note('Fight is starting...')` and... that's it! We're dispatching the event inside of `GameApplication` and we've already registered the listener here, so it should call it.

Let's try it! At your terminal, say:

```terminal
./bin/console app:game:play
```

We'll choose our character and... got it - `[NOTE] Fight is starting...`. If we fight again... we get the *same* thing. *Awesome*! But it would be *cooler* if we had a little more information inside of our listener, like who *won* the battle. That's the job of this event class. It can carry whatever data we want. For example, let's create a `public function __construct()`. For simplicity, I'm going to create two `public` properties called `$player` and `$ai`. *Awesome*! Over in `GameApplication`, we need to actually pass those in, so pass `$player` and `$ai` here. Then, over in our listener, our function will be passed a `FightStartingEvent` object. It always *was* - it just wasn't very useful before. Now we can say `Fight is starting against`, followed by `$event->ai->getNickname()`. *Super nice*. Let's give it a try! I'll run the command again and... sweet! We see `[NOTE] Fight is starting againstAI: Mage`. The only thing I did is miss my space after "against" so it looks nicer. I'll fix that really quick.

As I mentioned, you can really put whatever data you want on this `FightStartingEvent`. Heck, you could create a `public $shouldBattle =  true` property if you wanted to. And for your listener, you could say `$event->shouldBattle = false`. In `GameApplication`, you could actually set this event to a new `$event` object, dispatch it, and if they *shouldn't* battle, it would just `return`. Or you could `return FightResults()` and maybe throw an exception. Either way, you see the point. You can even send signals back about what you want to do. I'll undo all of that inside of `GameApplication`, `FightStartingEvent` and also `GameCommand`.

As easy as this inline listener is, it's more common to create a separate class for your listener. You can either create a *listener* class, which is basically a class that has this code here as a public function, *or* you can create a class called a *subscriber*. Both are completely valid ways to use the pub/sub pattern. The only difference is how you *register* a listener versus a subscriber, which is pretty minor, and you'll see that in a minute. So let's refactor this to a subscriber.

In the `/Event` directory, create a new PHP class called... how about... `OutputFightStartingSubscriber`, since this subscriber's going to *output* that a battle is beginning. Events listeners don't need to extend any base class or implement any interface, but event *subscribers* do. They need to implement the `EventSubscriberInterface`. Then I'll go "Code Generate" or "Command" + "N" on a Mac, go to "Implement Methods", and select `getSubscribedEvents()`. Nice! With an event subscriber, you'll list which events you subscribe to right inside this class. So we'll say `FightStartingEvent::class => 'onFightStart'`. This basically says:

`When that event happens, I want you to call the
onFightStart method in this class`.

So we'll create that with `public function onFightStart(FightStartingEvent $event)`. This will get the `FightStartingEvent` object. Then, for the guts of this, I'll go over to `GameCommand` and steal our `$io`. It's important to note that the `$io` is kind of hard to pass from console commands into other parts of your code. I'm going to ignore that complexity here and just create a new `$io` by saying `$io = new SymfonyStyle(new ArrayInput([]), new ConsoleOutput()`. I'm creating an object that's just like the normal `$io` object so I can cheat a little here.

Now that we have a subscriber, back in `GameCommand`, we're going to hook that up. So instead of `addListener()`, say `addSubscriber()`, and inside of that, `new OutputFightStartingSubscriber()`. Awesome!

Testing time! Moment of *truth*. I'll exit, choose my character and... wow! It's working *so* well, it's outputting *twice*. Why? This is, once again, thanks to auto configuration. We're using auto configuration inside of our application, so whenever we create a class that implements `EventSubscriberInterface`, the Symfony container is automatically taking that subscriber and registering it on the `eventDispatcher`. In other words, Symfony, internally, is already calling this line right here. So that answers the question of how we use the pub/sub pattern in Symfony.

I'll go delete that line inside of `GameCommand`. All you need to do is create an event subscriber like we've done here, and Symfony will automatically register it. Then, to *dispatch* an event, you'll create a new event class and dispatch that event anywhere in your code.

So you can see how easy it is to create the `eventDispatcher` and dispatch *all kinds* of events all over your application. If we try this again (I'll exit I battle first)... it only outputs *once*. Great! The benefits of pub/sub are really the same as the observer, but in practice, pub/sub is a bit more common. That's probably because Symfony has this great event dispatcher. Half of the work is already done *for* you.

Next, let's dive into our final pattern! It's one of my favorites *and* the most powerful in Symfony: The *decorator* pattern.
